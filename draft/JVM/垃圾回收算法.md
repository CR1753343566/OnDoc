# 垃圾回收算法

## 引用计数法

在Java中，引用和对象是有关联的。如果要操作对象必须用引用进行，因此，通过引用计数来判断一个对象是否可以回收。简单来说，如果 ***一个对象没有任何与之关联的引用，即他们的引用救赎都不为0，则说明对象不太可能被用到，那么这个对象就是可回收对象***

引用计数法会出现循环引用

    public class Obj{
        public Object ref=null;
        public static void main(String []args){
            Obj o1=new Obj();
            Obj o2=new Obj();
            o1.ref=o2;
            o2.ref=o1;
            o1=null;
            o2=null;
        }
    }

o1 与 o2 互为引用，如果采用引用计数法，o1 和 o2将不能回收，因为他们的引用技术无法为0

当执行完 `o1.ref=o2;o2.ref=o1;` 两个对象的引用计数都为2，此时将o1和o2分别置为null,以o1为例，他的引用计数将减1.若要满足垃圾回收的条件，需要清除`o2.ref`这个引用，而要清掉这个引用的前提条件是o2引用的对象被回收，可是o1的引用计数为1，因为o1.ref指向了o2

## 可达性分析

为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记 过程。两次标记后仍然是可回收对象，则将面临回收

## 标记清除算法

标记清除算法分为两个阶段，标记和清除。标记阶段标记出所需要回收的对象，清除阶段回收被标记对象所占用的空间

标记清除算法最大的问题是内存碎片化严重，可能出现大对象找不到可利用空间的问题

## 复制算法

将内存容量划分为等大小的两块，每次只使用其中一块，当这块内存满了之后将尚存活的对象复制到另一块上去，把已使用的内存清理掉

复制算法虽然实现简单，内存效率高，不易产生碎片，但是牺牲了空间，当对象存活较多的情况下，复制算法效率会降低

## 标记整理算法

标记后不是清理对象，而是将存活对象移向了内存的一端。然后清除端边界外的对象

## 分代收集算法

分代收集是目前JVM普遍采用的方法，核心思想是 ***根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代和新生代。老生代的特点是每次垃圾回收时只有少量的对象需要被回收，而新生代的特点是每次垃圾回收都有大量的垃圾需要被回收***

#### 新生代——>复制算法

目前大部分JVM的GC对于新生代都采用Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照`1:1`来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space，To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将两块空间还存活的对象复制到另一块Survivor空间

#### 老年代——>标记复制算法

老年代因为每次只回收少量对象，因而采用Mark-Compact 算法

## 总结

* 对象的内存分配主要在新生代的 Eden Space 和Survivor Space 的 From Space(Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代
* 新生代的 Eden Space 和 From Space 空间不足时就会发生一次GC，进行GC后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From
Space 进行清理，然后将From Space的对象复制到To Space进行下一次GC
* 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代
* 当对象在 Survivor 区躲过一次GC后，其年龄就会+1。默认情况下年龄到达 15 的对象会被 移到老生代中

